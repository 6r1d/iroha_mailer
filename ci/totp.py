"""
OTP generation code to protect from unwanted parties sending emails out.

References (initial):
https://github.com/tadeck/onetimepass (MIT)
https://stackoverflow.com/a/8549884/703462
"""

from random import randint
from datetime import datetime
from base64 import b32decode, b32encode
from struct import pack, unpack
from hashlib import sha1
from hmac import new as hmac_new
from binascii import Error as binascii_error

BIG_ENDIAN_64BIT_UNSIGNED_INT = '>Q'
SIGNED_POSITIVE_BITMASK_64 = 0x7fffffffffffffff
HOTP_LIMITER = 10 ** 19
HOTP_LIMITER_LEN = len(str(HOTP_LIMITER))-1

def secret_generator():
    """
    Base32 secret generator for get_totp_token.
    Used to generate the secret, shared by client and server.

    Example:
        > secret_generator()
        b'JZMFYT3QPFTFUEA='
    """
    return b32encode(
        ''.join(chr(randint(0, 127))
        for _ in range(9)).encode('ascii')
    )

def get_epoch_time() -> int:
    """Returns the current epoch time (UTC) as an integer.

    The returned epoch time represents the number of seconds elapsed since
    January 1, 1970 00:00:00 UTC, regardless of the local time zone.

    Returns:
        int: The epoch time as an integer.

    Example:
        >>> get_epoch_time()
        1707726522
        >>> get_epoch_time()
        1707726526
    """
    return int(datetime.utcnow().timestamp())

def get_circular_section(iterable, start, length):
    """
    Returns a section of `iterable` starting from `start` with `length` elements.
    If the section exceeds the iterable's bounds, it wraps around.
    
    Arguments:
        iterable: The iterable to slice
        start: The start index for slicing
        length: The number of elements in the section

    Return:
        (list): the section of the iterable
    """
    n = len(iterable)  # Get the length of the iterable
    # Calculate the effective start and end indices
    start = start % n
    end = (start + length) % n
    result = None
    if start + length <= n:
        # If the section doesn't wrap around, slice it directly
        result = iterable[start:start+length]
    else:
        # If the section wraps around, concatenate the two parts
        result = iterable[start:] + iterable[:end]
    return result

def get_hotp_token(secret: str, intervals_no: int):
    """
    HMAC-based One-Time Password generator, which is changed with each call.
    """
    # Decoding our key
    try:
        starting_key = b32decode(secret, True)
    except binascii_error as decode_error:
        raise ValueError('Unable to decode the secret') from decode_error
    # Conversions between Python values and C structs representation
    initial_hash_input = pack(BIG_ENDIAN_64BIT_UNSIGNED_INT, intervals_no)
    # Use keyed-hashing for message authentication,
    # a tamper-resistant approach to hashing.
    # Use sha1 as a hashing function to get 20 bytes for a hash.
    hashing_obj = hmac_new(starting_key, initial_hash_input, sha1).digest()
    # Pick last four bits of hashing_obj's last byte to get an offset
    o = hashing_obj[-1] & 15
    # Generate the hash
    # The "get_circular_section" operation allows to start at different locations
    # of the hashing object and strenghten the key.
    h = (
        unpack(
            BIG_ENDIAN_64BIT_UNSIGNED_INT,
            get_circular_section(hashing_obj, o, 8),
        )[0] & SIGNED_POSITIVE_BITMASK_64
    )
    # Limit hash length
    h = h % HOTP_LIMITER
    return h

def get_totp_token(secret: str) -> str:
    """
    Arguments:
        secret (str): a secret string, generated by the secret_generator

    Example:

        # Base32-encoded key
        secret = 'MNUGC2DBGBZQ===='
        token = get_totp_token(secret)
    """
    hotp_tmp = get_hotp_token(
        secret,
        intervals_no=get_epoch_time() // 30
    )
    # Adding 0 until OTP has 6 digits
    token = f"{hotp_tmp:06d}"
    return token

def gen_otp_from_secret_file(secret_path: str):
    """
    Generates the OTP given a secret file path.
    """
    secret = None
    with open(secret_path, 'r', encoding='ascii') as secret_file:
        secret = secret_file.read()
    return get_totp_token(secret)

def validate_otp(secret_path: str, otp: str) -> bool:
    """
    Returns:
        bool: does the OTP match the expected string?
    """
    return otp == gen_otp_from_secret_file(secret_path)
